let $camlTests12__first_const51 = Block 0 () in
let code `anon-fn[tests12.ml:15,52--67]_2` (param) my_closure -> k * k1 =
  let const = 0 in
  cont k (0)
in
let code `anon-fn[tests12.ml:15,39--51]_3` (x) my_closure -> k * k1 =
  cont k (x)
in
let code `anon-fn[tests12.ml:15,2--70]_1` (param) my_closure -> k * k1 =
  let map_foo =
    %project_var `anon-fn[tests12.ml:15,2--70]`.map_foo_0 my_closure
  in
  let `anon-fn[tests12.ml:15,52--67]` =
    closure `anon-fn[tests12.ml:15,52--67]_2`
      @`anon-fn[tests12.ml:15,52--67]`
  in
  let `anon-fn[tests12.ml:15,39--51]` =
    closure `anon-fn[tests12.ml:15,39--51]_3`
      @`anon-fn[tests12.ml:15,39--51]`
  in
  apply
    inline(never)
    map_foo
    (`anon-fn[tests12.ml:15,39--51]`, `anon-fn[tests12.ml:15,52--67]`, 0)
    -> k
    * k1
in
let code inline(always) bar_0 (map_foo) my_closure -> k * k1 =
  let sequence = 0 in
  let `anon-fn[tests12.ml:15,2--70]` =
    closure `anon-fn[tests12.ml:15,2--70]_1` @`anon-fn[tests12.ml:15,2--70]`
  with { map_foo_0 = map_foo }
  in
  cont k (`anon-fn[tests12.ml:15,2--70]`)
in
let code rec map_foo_4 (f, seq, param) my_closure -> k * k1 =
  let bar = %project_var map_foo.bar_1 my_closure in
  apply seq (0) -> k2 * k1
    where k2 (`*match*`) =
      let prim = %is_int `*match*` in
      let Pflambda_isint = %Tag_imm prim in
      ((let untagged = %untag_imm Pflambda_isint in
        switch untagged
          | 0 -> k2
          | 1 -> k3)
         where k3 =
           let untagged = %untag_imm `*match*` in
           cont k (0)
         where k2 =
           let prim_1 = %get_tag `*match*` in
           let Pgettag = %Tag_imm prim_1 in
           ((let untagged = %untag_imm Pgettag in
             cont k2)
              where k2 =
                ((let Popaque = %Opaque 0 in
                  (let untagged = %untag_imm Popaque in
                   switch untagged
                     | 0 -> k3
                     | 1 -> k4)
                    where k4 =
                      apply bar (my_closure) -> k2 * k1
                    where k3 =
                      apply bar (my_closure) -> k2 * k1)
                   where k2 (g) =
                     (apply inline(always) g (0) -> k2 * k1
                        where k2 (g_result) =
                          ((let ignore = %Opaque g_result in
                            let const = 0 in
                            cont k2 (0))
                             where k2 (sequence) =
                               let Pfield =
                                 %block_load 0 size 2 (`*match*`, 0)
                               in
                               (apply f (Pfield) -> k2 * k1
                                  where k2 (apply_result) =
                                    let Pmakeblock =
                                      %Block 0 (apply_result, g)
                                    in
                                    cont k (Pmakeblock)))))))
in
(let bar = closure bar_0 @bar in
 let map_foo = closure map_foo_4 @map_foo with { bar_1 = bar } in
 let Pmakeblock = %Block 0 (bar, map_foo) in
 cont k (Pmakeblock))
  where k (module_block) =
    let field_0 = %block_load 0 size 2 (module_block, 0) in
    let field_1 = %block_load 0 size 2 (module_block, 1) in
    let $camlTests12 = Block 0 (field_0, field_1) in
    cont done ($camlTests12)
===>
let code `anon-fn[tests12.ml:15,52--67]_2` deleted : val -> val in
let code `anon-fn[tests12.ml:15,39--51]_3` deleted : val -> val in
let code `anon-fn[tests12.ml:15,2--70]_1` deleted : val -> val in
let code inline(always) bar_0 deleted : val -> val in
let code rec map_foo_4 deleted : val * val * val -> val in
let code `anon-fn[tests12.ml:15,52--67]_2_1`
           newer_version_of(`anon-fn[tests12.ml:15,52--67]_2`) (param)
           my_closure -> k * k1 =
  cont k (0)
in
let $`camlTests12__anon-fn[tests12.ml:15,52--67]_6` =
  closure `anon-fn[tests12.ml:15,52--67]_2_1`
    @`anon-fn[tests12.ml:15,52--67]`
in
let code `anon-fn[tests12.ml:15,39--51]_3_1`
           newer_version_of(`anon-fn[tests12.ml:15,39--51]_3`) (x) my_closure
           -> k * k1 =
  cont k (x)
in
let $`camlTests12__anon-fn[tests12.ml:15,39--51]_7` =
  closure `anon-fn[tests12.ml:15,39--51]_3_1`
    @`anon-fn[tests12.ml:15,39--51]`
in
let code `anon-fn[tests12.ml:15,2--70]_1_1`
           newer_version_of(`anon-fn[tests12.ml:15,2--70]_1`) (param)
           my_closure -> k * k1 =
  let map_foo =
    %project_var `anon-fn[tests12.ml:15,2--70]`.map_foo_0 my_closure
  in
  apply
    inline(never)
    map_foo
    ($`camlTests12__anon-fn[tests12.ml:15,39--51]_7`,
     $`camlTests12__anon-fn[tests12.ml:15,52--67]_6`,
     0)
    -> k
    * k1
in
let code inline(always) bar_0_1 newer_version_of(bar_0) (map_foo) my_closure
                          -> k * k1 =
  let `anon-fn[tests12.ml:15,2--70]` =
    closure `anon-fn[tests12.ml:15,2--70]_1_1`
      @`anon-fn[tests12.ml:15,2--70]`
  with { map_foo_0 = map_foo }
  in
  cont k (`anon-fn[tests12.ml:15,2--70]`)
in
let $camlTests12__bar_5 = closure bar_0_1 @bar in
let set_of_closures
      $`camlTests12__anon-fn[tests12.ml:15,2--70]_10` =
      closure `anon-fn[tests12.ml:15,2--70]_1_3`
        @`anon-fn[tests12.ml:15,2--70]`
      with { map_foo_0 = $camlTests12__map_foo_8 }
    end
and set_of_closures $camlTests12__map_foo_8 = closure map_foo_4_1 @map_foo
    end
and set_of_closures
      $`camlTests12__anon-fn[tests12.ml:15,2--70]_9` =
      closure `anon-fn[tests12.ml:15,2--70]_1_2`
        @`anon-fn[tests12.ml:15,2--70]`
      with { map_foo_0 = $camlTests12__map_foo_8 }
    end
and code `anon-fn[tests12.ml:15,2--70]_1_2`
           newer_version_of(`anon-fn[tests12.ml:15,2--70]_1_1`) (param)
           my_closure -> k * k1 =
  apply
    direct(map_foo_4_1 @map_foo)
    inline(never)
    inlining_state (depth 1)
    $camlTests12__map_foo_8
    ($`camlTests12__anon-fn[tests12.ml:15,39--51]_7`,
     $`camlTests12__anon-fn[tests12.ml:15,52--67]_6`,
     0)
    -> k
    * k1
and code `anon-fn[tests12.ml:15,2--70]_1_3`
           newer_version_of(`anon-fn[tests12.ml:15,2--70]_1_1`) (param)
           my_closure -> k * k1 =
  apply
    direct(map_foo_4_1 @map_foo)
    inline(never)
    inlining_state (depth 1)
    $camlTests12__map_foo_8
    ($`camlTests12__anon-fn[tests12.ml:15,39--51]_7`,
     $`camlTests12__anon-fn[tests12.ml:15,52--67]_6`,
     0)
    -> k
    * k1
and code rec map_foo_4_1 newer_version_of(map_foo_4) (f, seq, param)
               my_closure -> k * k1 =
  apply seq (0) -> k2 * k1
    where k2 (`*match*`) =
      let prim = %is_int `*match*` in
      (switch prim
         | 0 -> k2
         | 1 -> k (0)
         where k2 =
           ((let Popaque = %Opaque 0 in
             let untagged = %untag_imm Popaque in
             switch untagged
               | 0 -> k2 ($`camlTests12__anon-fn[tests12.ml:15,2--70]_10`)
               | 1 -> k2 ($`camlTests12__anon-fn[tests12.ml:15,2--70]_9`))
              where k2 (g) =
                (apply
                   direct(map_foo_4_1 @map_foo)
                   inline(never)
                   inlining_state (depth 1)
                   $camlTests12__map_foo_8
                   ($`camlTests12__anon-fn[tests12.ml:15,39--51]_7`,
                    $`camlTests12__anon-fn[tests12.ml:15,52--67]_6`,
                    0)
                   -> k2
                   * k1
                   where k2 (g_result) =
                     let ignore = %Opaque g_result in
                     let Pfield = %block_load 0 size 2 (`*match*`, 0) in
                     (apply f (Pfield) -> k2 * k1
                        where k2 (apply_result) =
                          let Pmakeblock = %Block 0 (apply_result, g) in
                          cont k (Pmakeblock)))))
in
let $camlTests12 = Block 0 ($camlTests12__bar_5, $camlTests12__map_foo_8) in
cont done ($camlTests12)
